#
# This file is part of Astarte.
#
# Copyright 2025 SECO Mind Srl
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

defmodule Astarte.Pairing.FDO.OwnerOnboarding.ProveDevice do
  @moduledoc """
  TO2.ProveDevice (Type 64).
  From Device ROE to Owner Onboarding Service.

  This message contains a COSE_Sign1 object representing an EAT (Entity Attestation Token).
  It authenticates the device via signature verification and provides the second part
  of the Key Exchange (xB).

  Spec Reference: 5.5.6 TO2.ProveDevice, Type 64 [cite: 3148]
  """
  use TypedStruct
  alias Astarte.Pairing.FDO.OwnerOnboarding.ProveDevice

  # Alias per la libreria COSE (da adattare in base alla libreria effettiva in uso su Astarte)
  alias Astarte.Pairing.FDO.OwnerOnboarding.EAToken

  # --- IANA & FDO Constants (Appendix E & Spec 3.3.6) ---

  # EAT-FDO: FDO-specific claim wrapping the FDO payload (Label -257) [cite: 3456]
  @eat_fdo_label :fdo

  @eat_random <<1>>

  typedstruct enforce: true do
    @typedoc "Decoded content of the TO2.ProveDevice message."

    # 1. xBKeyExchange
    # The Device's public key contribution to the Key Exchange.
    # Extracted from the EAT Payload inside the EAT-FDO claim.
    # Spec: TO2ProveDevicePayload = [ xBKeyExchange ]
    field :xb_key_exchange, binary()

    # 2. NonceTO2ProveDv
    # The nonce originally sent by the Owner in TO2.ProveOVHdr.
    # Extracted from the EAT Payload (EAT-NONCE claim).
    # Ensures signature freshness[cite: 3154].
    field :nonce_to2_prove_dv, binary()

    # 3. NonceTO2SetupDv
    # A new Nonce generated by the Device for the next step (TO2.SetupDevice).
    # Extracted from the COSE Unprotected Headers (EUPHNonce)[cite: 3160].
    field :nonce_to2_setup_dv, binary()

    # 4. UEID (GUID)
    # The device GUID extracted from the EAT token.
    # Must match the GUID of the session.
    field :guid, binary()

    # Raw EAT token binary, useful for audit logging.
    field :raw_eat_token, binary()
  end

  @doc """
  Decodes the TO2.ProveDevice message, verifies the COSE signature using the
  Device Public Key, and extracts the required FDO fields.
  """
  @spec decode(binary(), any()) :: {:ok, t()} | {:error, atom()}
  def decode(binary_msg, device_pub_key) do
    with {:ok, cose_object} <- EAToken.verify_decode_cbor(binary_msg, device_pub_key),
         {:ok, xb_key} <- extract_fdo_payload(cose_object.payload),
         {:ok, nonce_prove} <- fetch_required(cose_object.payload, :nonce),
         {:ok, nonce_setup} <- fetch_required(cose_object.uhdr, :euphnonce),
         {:ok, ueid} <- fetch_required(cose_object.payload, :ueid),
         {:ok, guid} <- guid_from_ueid(ueid) do
      {:ok,
       %ProveDevice{
         xb_key_exchange: xb_key,
         nonce_to2_prove_dv: nonce_prove,
         nonce_to2_setup_dv: nonce_setup,
         guid: guid,
         raw_eat_token: binary_msg
       }}
    end
  end

  # Extracts xBKeyExchange from the EAT-FDO claim array
  # Spec: TO2ProveDevicePayload = [ xBKeyExchange ]
  defp extract_fdo_payload(payload_map) do
    case Map.fetch(payload_map, @eat_fdo_label) do
      {:ok, [%CBOR.Tag{tag: :bytes, value: xb_key}]} when is_binary(xb_key) -> {:ok, xb_key}
      {:ok, _invalid_structure} -> {:error, :invalid_fdo_claim_structure}
      :error -> {:error, :missing_eat_fdo_claim}
    end
  end

  defp fetch_required(map, key) do
    case Map.fetch(map, key) do
      {:ok, val} -> {:ok, val}
      :error -> {:error, :message_body_error}
    end
  end

  defp guid_from_ueid(ueid) do
    with %CBOR.Tag{tag: :bytes, value: ueid} <- ueid,
         <<@eat_random::binary, guid::binary-size(16)>> <- ueid do
      {:ok, guid}
    else
      _ -> {:error, :message_body_error}
    end
  end
end

#
# This file is part of Astarte.
#
# Copyright 2025 SECO Mind Srl
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

defmodule Astarte.Pairing.FDO.OwnerOnboarding.ProveDevice do
  @moduledoc """
  TO2.ProveDevice (Type 64).
  From Device ROE to Owner Onboarding Service.

  This message contains a COSE_Sign1 object representing an EAT (Entity Attestation Token).
  It authenticates the device via signature verification and provides the second part
  of the Key Exchange (xB).

  Spec Reference: 5.5.6 TO2.ProveDevice, Type 64 [cite: 3148]
  """
  use TypedStruct
  alias Astarte.Pairing.FDO.OwnerOnboarding.ProveDevice

  # xB keys generation
  alias Astarte.Pairing.FDO.OwnerOnboarding.SessionKey
  alias COSE.Keys.ECC
  alias COSE.Messages.Sign1

  # Alias per la libreria COSE (da adattare in base alla libreria effettiva in uso su Astarte)
  alias Astarte.Pairing.FDO.OwnerOnboarding.EAToken

  # --- IANA & FDO Constants (Appendix E & Spec 3.3.6) ---

  # EAT-FDO: FDO-specific claim wrapping the FDO payload (Label -257) [cite: 3456]
  @eat_fdo_label -257
  @eat_nonce_label 10
  @eat_ueid_label 256
  @euph_nonce -259

  @eat_random <<1>>

  @nonce_binary_size 16

  typedstruct enforce: true do
    @typedoc "Decoded content of the TO2.ProveDevice message."

    # 1. xBKeyExchange
    # The Device's public key contribution to the Key Exchange.
    # Extracted from the EAT Payload inside the EAT-FDO claim.
    # Spec: TO2ProveDevicePayload = [ xBKeyExchange ]
    field :xb_key_exchange, binary()

    # 2. NonceTO2ProveDv
    # The nonce originally sent by the Owner in TO2.ProveOVHdr.
    # Extracted from the EAT Payload (EAT-NONCE claim).
    # Ensures signature freshness[cite: 3154].
    field :nonce_to2_prove_dv, binary()

    # 3. NonceTO2SetupDv
    # A new Nonce generated by the Device for the next step (TO2.SetupDevice).
    # Extracted from the COSE Unprotected Headers (EUPHNonce)[cite: 3160].
    field :nonce_to2_setup_dv, binary()

    # 4. UEID (GUID)
    # The device GUID extracted from the EAT token.
    # Must match the GUID of the session.
    field :guid, binary()

    # Raw EAT token binary, useful for audit logging.
    field :raw_eat_token, binary()
  end

  @doc """
  Decodes the TO2.ProveDevice message, verifies the COSE signature using the
  Device Public Key, and extracts the required FDO fields.
  """
  @spec decode(binary(), any()) :: {:ok, t()} | {:error, atom()}
  def decode(binary_msg, device_pub_key) do
    with {:ok, cose_object} <- EAToken.verify_decode_cbor(binary_msg, device_pub_key),
         {:ok, xb_key} <- extract_fdo_payload(cose_object.payload),
         {:ok, nonce_prove} <- fetch_binary(cose_object.payload, :nonce),
         :ok <- check_expected_binary_size(nonce_prove, @nonce_binary_size),
         {:ok, nonce_setup} <- fetch_binary(cose_object.uhdr, :euphnonce),
         :ok <- check_expected_binary_size(nonce_setup, @nonce_binary_size),
         {:ok, ueid} <- fetch_binary(cose_object.payload, :ueid),
         {:ok, guid} <- guid_from_ueid(ueid) do
      {:ok,
       %ProveDevice{
         xb_key_exchange: xb_key,
         nonce_to2_prove_dv: nonce_prove,
         nonce_to2_setup_dv: nonce_setup,
         guid: guid,
         raw_eat_token: binary_msg
       }}
    else
      _ -> {:error, :message_body_error}
    end
  end

  @doc false
  def generate() do
    {:ok, _, xb} = SessionKey.new("ECDH256", ECC.generate(:es256))

    %ProveDevice{
      xb_key_exchange: xb,
      nonce_to2_prove_dv: :crypto.strong_rand_bytes(16),
      nonce_to2_setup_dv: :crypto.strong_rand_bytes(16),
      guid: :crypto.strong_rand_bytes(16),
      raw_eat_token: <<>>
    }
  end

  def encode_sign(%ProveDevice{} = prove_device_payload, priv_key) do
    # TODO add a EAToken.encode() function to create the EAT payload
    eat_cbor_payload =
      prove_device_payload
      |> prove_device_payload_to_cbor()

    phdr = %{alg: :es256}

    uhdr = %{@euph_nonce => prove_device_payload.nonce_to2_setup_dv |> COSE.tag_as_byte()}

    Sign1.build(eat_cbor_payload, phdr, uhdr) |> Sign1.sign_encode_cbor(priv_key)
  end

  # Extracts xBKeyExchange from the EAT-FDO claim array
  # Spec: TO2ProveDevicePayload = [ xBKeyExchange ]
  defp extract_fdo_payload(payload_map) do
    case Map.fetch(payload_map, :fdo) do
      {:ok, [%CBOR.Tag{tag: :bytes, value: xb_key}]} when is_binary(xb_key) -> {:ok, xb_key}
      _ -> {:error, :message_body_error}
    end
  end

  defp fetch_binary(map, key) do
    with {:ok, value} <- Map.fetch(map, key),
         %CBOR.Tag{tag: :bytes, value: value} <- value do
      {:ok, value}
    else
      _ -> {:error, :message_body_error}
    end
  end

  defp check_expected_binary_size(binary_val, expected_len) do
    case byte_size(binary_val) do
      ^expected_len ->
        :ok

      _ ->
        {:error, :message_body_error}
    end
  end

  defp guid_from_ueid(ueid) do
    case ueid do
      <<@eat_random::binary, guid::binary-size(16)>> -> {:ok, guid}
      _ -> {:error, :message_body_error}
    end
  end

  defp prove_device_payload_to_cbor(prove_device_payload) do
    %{
      @eat_fdo_label => [prove_device_payload.xb_key_exchange |> COSE.tag_as_byte()],
      @eat_nonce_label => prove_device_payload.nonce_to2_prove_dv |> COSE.tag_as_byte(),
      @eat_ueid_label => (@eat_random <> prove_device_payload.guid) |> COSE.tag_as_byte()
    }
    |> CBOR.encode()
  end
end

#
# This file is part of Astarte.
#
# Copyright 2025 SECO Mind Srl
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

defmodule Astarte.Pairing.FDO.OwnerOnboarding.ProveDevice do
  @moduledoc """
  TO2.ProveDevice (Type 64).
  From Device ROE to Owner Onboarding Service.

  This message contains a COSE_Sign1 object representing an EAT (Entity Attestation Token).
  It authenticates the device via signature verification and provides the second part
  of the Key Exchange (xB).

  Spec Reference: 5.5.6 TO2.ProveDevice, Type 64 [cite: 3148]
  """
  use TypedStruct
  alias Astarte.Pairing.FDO.OwnerOnboarding.ProveDevice

  # xB keys generation
  alias Astarte.Pairing.FDO.OwnerOnboarding.SessionKey
  alias COSE.Keys.ECC

  # EAToken encoding and decoding
  alias Astarte.Pairing.FDO.OwnerOnboarding.EAToken

  @nonce_binary_size 16

  # EUPHNonce: Nonce in unprotected headers (Label -259)
  @euph_nonce -259

  typedstruct enforce: true do
    @typedoc "Decoded content of the TO2.ProveDevice message."

    # 1. xBKeyExchange
    # The Device's public key contribution to the Key Exchange.
    # Extracted from the EAT Payload inside the EAT-FDO claim.
    # Spec: TO2ProveDevicePayload = [ xBKeyExchange ]
    field :xb_key_exchange, binary()

    # 2. NonceTO2ProveDv
    # The nonce originally sent by the Owner in TO2.ProveOVHdr.
    # Extracted from the EAT Payload (EAT-NONCE claim).
    # Ensures signature freshness[cite: 3154].
    field :nonce_to2_prove_dv, binary()

    # 3. NonceTO2SetupDv
    # A new Nonce generated by the Device for the next step (TO2.SetupDevice).
    # Extracted from the COSE Unprotected Headers (EUPHNonce)[cite: 3160].
    field :nonce_to2_setup_dv, binary()

    # 4. UEID (GUID)
    # The device GUID extracted from the EAT token.
    # Must match the GUID of the session.
    field :guid, binary()

    # Raw EAT token binary, useful for audit logging.
    field :raw_eat_token, binary()
  end

  def euph_nonce_claim_key, do: @euph_nonce

  @doc """
  Decodes the TO2.ProveDevice message, verifies the COSE signature using the
  Device Public Key, and extracts the required FDO fields.
  """
  @spec decode(binary(), any()) :: {:ok, t()} | {:error, atom()}
  def decode(binary_msg, device_pub_key) do
    extra_uhdr_claims = %{euph_nonce_claim_key() => :euph_nonce}

    with {:ok, cose_object} <-
           EAToken.verify_decode_cbor(binary_msg, device_pub_key, %{}, extra_uhdr_claims),
         {:ok, xb_key} <- extract_fdo_payload(cose_object.payload),
         {:ok, nonce_prove} <- fetch_binary(cose_object.payload, :nonce),
         :ok <- check_expected_binary_size(nonce_prove, @nonce_binary_size),
         {:ok, nonce_setup} <- fetch_binary(cose_object.uhdr, :euph_nonce),
         :ok <- check_expected_binary_size(nonce_setup, @nonce_binary_size),
         {:ok, ueid} <- fetch_binary(cose_object.payload, :ueid),
         {:ok, guid} <- guid_from_ueid(ueid) do
      {:ok,
       %ProveDevice{
         xb_key_exchange: xb_key,
         nonce_to2_prove_dv: nonce_prove,
         nonce_to2_setup_dv: nonce_setup,
         guid: guid,
         raw_eat_token: binary_msg
       }}
    end
  end

  @doc false
  def generate() do
    {:ok, _, xb} = SessionKey.new("ECDH256", ECC.generate(:es256))

    %ProveDevice{
      xb_key_exchange: xb,
      nonce_to2_prove_dv: :crypto.strong_rand_bytes(16),
      nonce_to2_setup_dv: :crypto.strong_rand_bytes(16),
      guid: :crypto.strong_rand_bytes(16),
      raw_eat_token: <<>>
    }
  end

  def encode_sign(%ProveDevice{} = prove_device_payload, priv_key) do
    payload_claims = %{
      fdo: [prove_device_payload.xb_key_exchange |> COSE.tag_as_byte()],
      nonce: prove_device_payload.nonce_to2_prove_dv |> COSE.tag_as_byte(),
      ueid: EAToken.build_ueid(prove_device_payload.guid) |> COSE.tag_as_byte()
    }

    uhdr_claims = %{
      euph_nonce: prove_device_payload.nonce_to2_setup_dv |> COSE.tag_as_byte()
    }

    # euph_nonce is FDO-specific, not part of standard EAT, so pass as extra claim
    extra_uhdr_claims = %{@euph_nonce => :euph_nonce}

    EAToken.encode_sign(payload_claims, uhdr_claims, priv_key, %{}, extra_uhdr_claims)
  end

  # Extracts xBKeyExchange from the EAT-FDO claim array
  # Spec: TO2ProveDevicePayload = [ xBKeyExchange ]
  defp extract_fdo_payload(payload_map) do
    case Map.fetch(payload_map, :fdo) do
      {:ok, [%CBOR.Tag{tag: :bytes, value: xb_key}]} when is_binary(xb_key) -> {:ok, xb_key}
      _ -> {:error, :message_body_error}
    end
  end

  defp fetch_binary(map, key) do
    with {:ok, value} <- Map.fetch(map, key),
         %CBOR.Tag{tag: :bytes, value: value} <- value do
      {:ok, value}
    else
      _ -> {:error, :message_body_error}
    end
  end

  defp check_expected_binary_size(binary_val, expected_len) do
    case byte_size(binary_val) do
      ^expected_len ->
        :ok

      _ ->
        {:error, :message_body_error}
    end
  end

  defp guid_from_ueid(ueid) do
    case EAToken.parse_ueid(ueid) do
      {:ok, guid} -> {:ok, guid}
      {:error, :invalid_ueid} -> {:error, :message_body_error}
    end
  end
end
